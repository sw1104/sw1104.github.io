---
title: "[TypeScript] TypeScript 파헤치기"
excerpt: "TypeScript에 대해 파헤치기"

categories:
  - TypeScript
tags:
  - [TypeScript]

permalink: /typescript/concept

toc: true
toc_sticky: true

date: 2023-02-21
last_modified_at: 2023-02-21
---

### TypeScript 공부 전에

- typescript는 최종적으로 javascript로 변환된다. 순수하게 typescript 코드를 돌릴 수 있는 런타임인 deno가 있지만 대중적이지 않다.

- typescript는 언어이며 컴파일러(tsc) 이다. tsc는 ts코드를 js로 변환한다.

- tsc의 설정은 tsconfig.json에서 하며 I/O (ts/js) 모두에 영향을 준다.

- 단순히 타입 검사만 하고자 한다면 tsc --noEmit을 이용하면 된다.

- 프로젝트 실행은 ts가 아닌 js를 실행해야 한다.

### TypeScript 문법

#### 변수, 속성, 매개변수, 리턴 값 등에 타입이 붙음

```javascript
const num: number = 123;
function add( a: number, b:number ): number { return a + y };
const add: ( a: number, b:number ) => number = (a, b) => a + b;
const obj: { num: number, str: string } = { num: 123, str: '123' };
```

#### 특수한 타입 {} (null과 undefined 가 아닌 모든 타입)

```javascript
const a: {} = 5;
```

#### ts에서 추론해주는 경우 그대로 사용하고 추론 못하면 직접 타이핑

```javascript
const a = 1;
const b = 2;
const c = a + b;
function add( a: number, b: number ) { return a + b };
```

#### `:`다음, as 다음, `<>`, interface, type, function 일부를 제외하면 자바스크립트와 동일함 

```javascript
const obj: { num: number, str: string } = { num: 123, str: '123' };
const obj = { num: 123, str: '123' };

const a = document.querySelector('#root') as HTMLDivElement;
const a = document.querySelector('#root');

function add<T> (a: T, b: T): T { return a + b };
function add(a, b) { return a + b };

interface A {};
type A = {};
```

#### js에 비해 자유도가 줄어듦

```javascript
let a = 123;
a = '123'; // Type 'string' is not assignable to type 'number'.
```

#### never, unknown, any 타입 주의! any는 최대한 쓰지 않는 것을 목표로

[never 좋은 설명](https://ui.toast.com/weekly-pick/ko_20220323)

```javascript
try {
  const array = []; // noImplicitAny가 false일 때
  array[0];
} catch(error) {
  error;
}
```

#### ! 대신 if 쓸 것

```javascript
const head = document.querySelector('#head');
console.log(head);

const head = document.querySelector('#head');
if (head) {
  console.log(head);
}
```

#### 타입은 소문자로 string과 String은 다르다. 대문자는 interface

```javascript
const a: string = 'hello';
const b: String = 'hell';
```

#### 템플릿 리터럴 타입이 존재(유니언 등 사용 가능)

```javascript
type World = 'world' | 'hell';

// type Greeting = "hello world"
type Greeting = `hello ${World}`;
```

#### 배열, 튜플 문법

```javascript
let arr: string[] = [];
let arr2: Array<string> = [];
function rest(...args: string[]) {}

const tuple: [string, number] = ['1', 1];
tuple[2] = 'hello';
tuple.push('hello');
```

#### enum, keyof, typeof

```javascript
const enum EDirection {
  Up,
  Down,
  Left,
  Right,
}
 
const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;
 
EDirection.Up;
           
(enum member) EDirection.Up = 0
 
ODirection.Up;
           
(property) Up: 0
 
// Using the enum as a parameter
function walk(dir: EDirection) {}
 
// It requires an extra line to pull out the keys
type Direction = typeof ODirection[keyof typeof ODirection];
function run(dir: Direction) {}
 
walk(EDirection.Left);
run(ODirection.Right);
```
#### 객체 type과 interface 구분

```javascript
type A = { a: string };
const a: A = { a: 'hello' };

interface B { a: string }
const b: B = { a: 'hello' };
```
#### union, intersection

```javascript
function add(x: string | number, y: string | number): string | number { return x + y }
add(1, 2)
add('1', '2')
add(1, '2')

type A = {
    a: string;
}
type B = {
    b: string;
}

const aa: A | B = { a: 'hello', b: 'world' };
const bb: A & B = { a: 'hello', b: 'world' };
```

#### interface끼리는 서로 합쳐진다.

```javascript
interface A { a: string }
interface A { b: string }
const obj1: A = { a: 'hello', b: 'world' }

type B = { a: string }
type B = { b: string }
const obj2: B = { a: 'hello', b: 'world' }
```
#### 객체 리터럴은 잉여 속성 검사가 있다.

```javascript
type A = { hello: string };
const a: A = { hello: 'world', why: 'error' };

const b = { hello: 'world', why: 'error' };
const c: A = b;
```
#### void 타입은 return 값이 없다는 뜻

```javascript
declare function forEach<T>(arr: T[], callback: (el: T) => undefined): void;
// declare function forEach<T>(arr: T[], callback: (el: T) => void): void;
let target: number[] = [];
forEach([1, 2, 3], el => target.push(el));

interface A {
    talk: () => void;
}
const a: A = {
    talk() { return 3; }
}

```

#### 타입만 선언하고 싶을 때 declare(구현은 다른 파일에서)

```javascript
declare const a: string;
declare function a(x: number): number;
declare class A {}

// declare module, declare global, declare namespace도 있음
```

#### 타입간 대입 가능한 표

||any|unknown|object|void|undefined|null|never|
|---|---|---|---|---|---|---|---|
|any||O|O|O|O|O|O|X|
|unknown|O||X|X|X|X|X|
|object|O|O||X|X|X|X|
|void|O|O|X||X|X|X|
|undefined|O|O|O|O||O|X|
|null|O|O|O|O|O||X|
|never|O|O|O|O|O|O||

#### 타입 가드

```javascript
function numOrStr(a: number | string) {
  if (typeof a === 'string') {
    a.split(',');  
  } else {
    a.toFixed(1);
  }
}

function numOrNumArr(a: number | number[]) {
  if (Array.isArray(a)) {
    a.slice(1);  
  } else {
    a.toFixed(1);
  }
}

type B = { type: 'b', bbb: string };
type C = { type: 'c', ccc: string };
type D = { type: 'd', ddd: string };
type A = B | C | D;
function typeCheck(a: A) {
  if (a.type === 'b') {
    a.bbb;
  } else if (a.type === 'c') {
    a.ccc;
  } else {
    a.ddd;
  }
}

interface Cat { meow: number }
interface Dog { bow: number }
function catOrDog(a: Cat | Dog): a is Dog {
  if ((a as Cat).meow) { return false }
  return true;
}
const cat: Cat | Dog = { meow: 3 }
if (catOrDog(cat)) {
    console.log(cat.meow);
}
if ('meow' in cat) {
    console.log(cat.meow);
}

const isRejected = (input: PromiseSettledResult<unknown>): input is PromiseRejectedResult => input.status === 'rejected';
const isFulfilled = <T>(input: PromiseSettledResult<T>): input is PromiseFulfilledResult<T> => input.status === 'fulfilled';

const promises = await Promise.allSettled([Promise.resolve('a'), Promise.resolve('b')]);
const errors = promises.filter(isRejected);
```

#### readonly

```javascript
interface A {
  readonly a: string;
  b: string;
}
```

#### class에 private, protected

```javascript
class B implements A {
  private a: string;
  protected b: string;
}
class C extends B {}
new C().a;
new C().b;
```

#### abstract class, abstract method

```javascript
abstract class X {
  abstract work(user: User): boolean;
}
class Y extends X {
  work(user: User): boolean {
    return true;
  }
}
```

#### abstract class, abstract 생성자

```javascript
const constructor: abstract new (...args: any) => any = ...
```

#### class와 interface 차이

- 런타임에서 있느냐 없느냐.


# 계속해서 추가

```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
```javascript

```
